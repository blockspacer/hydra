#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\end_header

\begin_body

\begin_layout Title
Methodology
\end_layout

\begin_layout Author
Joonatan Kuosa
\end_layout

\begin_layout Standard
My suggestion is that we use Extreme Programming (XP) approach to this project.
 Because we have a really small programming team, two people, we need to
 modify the XP methodology a little bit.
\end_layout

\begin_layout Standard
XP is an iterative software design and development methodology.
 Meaning that we don't try to capture all the necessary features and make
 a perfect design at the start of the project but we focus on appility to
 modify the design when new features are needed or problems occur.
\end_layout

\begin_layout Section
Short intoduction to Extreme Programming
\end_layout

\begin_layout Standard
Traditional software design is based on engineering practices and projects.
 In engineering projects you have a linear process, where first you gather
 necessary features from customers, then make a design, analyzise the design
 and implement it.
 For machine design and similar traditional engineering fields this is a
 good practice because the costs of changing something e.g.
 building prototypes and so on is so high that you can't go back in the
 process.
\end_layout

\begin_layout Standard
Software design is different because there is no necessary cost in changing
 something after the design and analysis phases.
 Iterative design methods arise from this, in iterative methods we assume
 that there will be multiple design and analyzis phases and that the implementat
ion has to be started as fast as possible to test the current design and
 to provide the features customer requested.
 Benefit from delivering working software as fast as possible is also that
 the customer can give feedback before the dead line, as usually there are
 problems in the design that can not be found with analysis alone but need
 the implementation.
\end_layout

\begin_layout Subsection
Communication
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add meat to this section.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Iterative methods especially XP promotes communication between the team
 members and between the customer.
 There is no traditional hierarchy in XP instead everyone has his say, developer
s define their own dead lines and anyone can call up a meeting if things
 are not going as planned.
 Fast response to any arising anomaly is promoted.
 Also developers and customer representative meet at least once an iteration
 which usually means once a week.
\end_layout

\begin_layout Standard
Customer is present in all design meetings and choses the priority of the
 features.
 Features are represented as user stories which are in plain english what
 the system should do without any references to the technology.
 Customer is also present in iteration meetings and also always near at
 hand so he can be asked questions to assure that the developers understood
 what he wanted.
\end_layout

\begin_layout Subsection
Release early and release often
\end_layout

\begin_layout Standard
Releases are few months apart from each other.
 Every release is planned in the release meeting and features for it are
 chosen.
 These features are represented by user stories.
 Not all user stories are implemented in one release, but all user stories
 are given ideal programming time needed to implement that user story.
 Together the developers and the customers decides which user stories should
 be implemented in the next release.
 The user stories and the time needed complete them will determine the amount
 of iterations necessary to complete the release.
\end_layout

\begin_layout Standard
Every release is divided into maybe a dozen of iterations.
 Iteration is small, 1-3 weeks, and every iteration has to provide working
 implementation of the software with the features chosen by the customer
 for that iteration.
 Iterations are planned in iteration meeting just before the iteration starts.
 Never plan iteration ahead.
\end_layout

\begin_layout Standard
If the tasks chosen for this iteration can not be completed in time new
 iteration meeting is called and the customer can decide what tasks are
 the most important ones.
 Never work on more than one task at a time, you deliver more working good
 quality software if you finish one task at a time.
 And as always customer decides what is important and what is not, not the
 developer.
\end_layout

\begin_layout Subsection
Design and Analysis
\end_layout

\begin_layout Standard
The XP approach to everything is 
\begin_inset Quotes eld
\end_inset

The less you do in advance the better, instead do everything in time
\begin_inset Quotes erd
\end_inset

.
 XP assumes that the design is never good enough and it will always change
 at some point.
 You should instead start with a basic design that solves the problem and
 provide value to the customer and later on you can refactor the code when
 the design evolves.
 Perfect and ultimate designs are not useful for software.
 They are instead destructive as the time spent on incorrect design
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Any design that does not help the customer is incorrect.
\end_layout

\end_inset

 is the time not spent on beign productive.
 Also long design phases needlesly slow down the implementation and testing.
\end_layout

\begin_layout Standard
Design starts with the user stories which are provided by the customer.
 These user stories are broken down by the developer, who is assigned to
 solve the problem, to use cases and tasks which are implementable.
\end_layout

\begin_layout Standard
Design phase provides the abstract interface necessary for implementation
 also it descripes what the parts do in the design.
 So one can write tests to verify that the parts do what they are designed
 to do.
\end_layout

\begin_layout Subsection
Spikes
\end_layout

\begin_layout Standard
Spikes are small programs that are designed to test technology.
 They are designed and implemented to confirm that particular idea or design
 is implementable with the technology we are using.
 
\end_layout

\begin_layout Standard
They are not usually production quality code and are not required to confirm
 to the overall design of the software product.
 That said spikes should not be used as production code as is.
 Their purpose is simply to test the technology and they can be discarded
 after the features they are used to test are introduced to the software
 product.
\end_layout

\begin_layout Standard
Spikes should never be integrated in to the production code and they don't
 need updating after the initial introduction.
 Instead you should provide unit tests if you already have the design.
 If they are versioned they should be removed from the version control after
 the production code is provided i.e.
 they should be discarded.
 This can not be stressed enough, spikes don't need updating instead you
 should provide unit tests and acceptance tests confirming to the overall
 and specific design, then provide the implementation.
 Spikes don't answer to question 
\begin_inset Quotes eld
\end_inset

how to do this
\begin_inset Quotes erd
\end_inset

 they answer to question 
\begin_inset Quotes eld
\end_inset

is it possible to do this with that technology
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Test Driven Design
\end_layout

\begin_layout Standard
Test Driven Design (TDD) is the really distinct method of XP.
 In TDD all the tests are writen before the implementation after the design
 and analysis phase.
 This quaranties that every piece of software is tested thoroughly, that
 the programmer wastes as little time as possible in writing useless implementat
ion and that design errors are caught as fast as possible before all the
 implementation is done.
 All tests will work as documentation on already working parts of the software
 and also as regression test when refactoring
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Refactoring"

\end_inset

.
\end_layout

\begin_layout Standard
In analysis the user story is broken down to task which are implementable
 so we can write tests for these tasks.
 The tasks represent functions or methods.
 We can start writing the interface based on the tasks and after the interface
 necessary to complete the specific tasks is done we can write unit tests
 for those methods and functions.
 When those unit tests fail because there is no implementation we can start
 working on the implementation so that our unit tests pass.
\end_layout

\begin_layout Standard
The quality of the implementation is dependent on the quality of the unit
 tests so don't overlook writing the unit tests.
\end_layout

\begin_layout Subsubsection
Unit Tests
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add bit more meat to this part.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also know as a developers test can be defined as 
\begin_inset Quotes eld
\end_inset

a test writen by and for the developer to test the functionality of the
 software
\begin_inset Quotes erd
\end_inset

 or as 
\begin_inset Quotes eld
\end_inset

the smallest possible test one can perform, ideally it would be executed
 in complete isolation
\begin_inset Quotes erd
\end_inset

.
 Depending on person you ask you either get the first definition or more
 usually the second one.
\end_layout

\begin_layout Standard
We use unit tests in the first sense, they are not needed for anything else
 than to test the software the developer is working on.
 This includes before the first implementation and after it during refactoring.
 The second definition has merits though, unit tests should test minimal
 functionality and be as isolated as possible.
\end_layout

\begin_layout Standard
My suggestions here is to agree that external libraries we use we can not
 test and just assume they work correctly.
 Everything we implement we can test so when writing a unit test module
 for a class or package they should be isolated from our other code.
 For classes this is easy enough using mock objects (mocks).
 Mocks are objects that provide the same interface without providing implementat
ion, they can also be checked to see if their public methods were invoced
 and how many times.
\end_layout

\begin_layout Standard
When needed external functionality say an external library needs to be initializ
ed before some of the methods of our class are usable, this is the case
 with Equalizer.
 We need to use fixtures to initialize that library or the necessary classes
 in that library before we can run our unit tests.
 Fixture is simply a class providing initialization and clean up for a test.
 They might introduce more errors especially when they are complex, but
 I'd still say that it's unit test.
 And without rewriting the external library we really can't get around this
 problem.
\end_layout

\begin_layout Standard
Unit test should should be writen in XP terms for 
\begin_inset Quotes eld
\end_inset

everything that may break
\begin_inset Quotes erd
\end_inset

, this includes tests for exceptions and special cases.
 Also never test anything else than the interface, anything private does
 not need to be tested as it's implementation and someone refactoring it
 would fail the unit tests even though it does not affect the customer in
 anyway.
\end_layout

\begin_layout Subsubsection
Integration Tests
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rewrite this part.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tests the interaction of multiple classes.
 Integration tests are not necessarily automated and they can not really
 test all or even a significant subset of the possible paths of execution
 so integration tests are what the developer assumes is the use of the software.
\end_layout

\begin_layout Standard
For example network code that is tested using mocks in unit test would have
 an integration test that would include both the sending and receiving end,
 same goes for threaded code.
\end_layout

\begin_layout Standard
Integration tests don't need to be automated, they might be but they don't
 have to so simple asserts used in unit tests are not necessary.
 The tests can be more complex and need a human to see if the test is passed
 or failed.
 Integration tests also don't need to be run always when new functionality
 is added or even everyday.
 They need to be run before the iteration ends to see that the new functionality
 did not break anything and that the new features are working correctly.
\end_layout

\begin_layout Subsubsection
Acceptance Tests
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rewrite this part.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also know as functional tests are the test that tell us if the software
 solution does what it is required to do.
 In XP acceptance tests are created by the customer and they match the user
 stories.
 One user story always has at least one acceptance test so the customer
 can validate that the functionality he wanted is working.
 Mind that 
\begin_inset Quotes eld
\end_inset

created by the customer
\begin_inset Quotes erd
\end_inset

 does not mean that the customer has to program the test this would also
 imply that the interface would be ready before the acceptance test could
 be defined.
 It simply means that the customer is providing detailed specification on
 what the system should do to a developer who then translates that to a
 program.
\end_layout

\begin_layout Standard
Acceptance tests are necessary for both iterations and releases as they
 tell us which of the features desided upon for this iteration or releases
 are ready and do not need more work done.
 This gives the programmer the feedback to stop working on a problem that
 is solved and also we have something to present to the customer.
\end_layout

\begin_layout Standard
Acceptance tests also give us the specifications on what to work on and
 what unit tests should be writen to pass that particular acceptance test
 and advance the project.
\end_layout

\begin_layout Subsection
Refactoring
\begin_inset CommandInset label
LatexCommand label
name "sub:Refactoring"

\end_inset


\end_layout

\begin_layout Standard
There is no such thing as perfect design, there will always be flaws and
 things that could be done better or differently.
 Customer always wants different features than what he wanted before or
 what you understood that he wanted.
 This is where XP comes into real power.
 In traditional software project refactoring is an anathema, it just can
 not be done or it will cost enourmously to do and still have working product
 in the end.
\end_layout

\begin_layout Standard
Refactoring is needed when the design changes because the customers needs
 change, an error in the original design, to improve maintanability or to
 clean up the code.
 Refactoring can be done at any point in the software cycle, it does not
 necessarily mean a big change between major versions it can also mean change
 between iterations or minor releases.
\end_layout

\begin_layout Standard
The problem of refactoring is that it changes working implementation and
 when you change something you always have to possibility that you break
 something.
 Refactoring is not necessary in that the software is working correctly
 but there is something that is not good enough for current needs.
\end_layout

\begin_layout Standard
Traditional software project answers this question with trying to do a perfect
 design so no refactoring will ever be needed.
 Sadly this does not work there are always situations where the design needs
 to change, where the customer wants something else and so on.
 What the perfect design does though is to waste huge amounts of time on
 designing a software without delivering anything.
\end_layout

\begin_layout Standard
Extreme Programming answers the problem of refactoring by not denying the
 problem but acknowledging it and trying to make it as easy to deal with
 as possible.
 In fact XP nor any other iterative design methodology even treats refactoring
 as a problem but as an inherit part of software development cycle
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wikipedia-refactoring"

\end_inset

.
 Following TDD there is tests for everything so there is a complete regression
 test suite without using any effort for creating it.
 So refactoring is not more of a problem than creating bunch of new functions
 it's even easier than that as you should not need to create new tests for
 refactoring.
 You just modify the implementation and see how many of your tests fail
 after that.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "wikipedia-refactoring"

\end_inset

http://en.wikipedia.org/wiki/Refactoring
\end_layout

\end_body
\end_document
