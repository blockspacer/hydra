/**	Joonatan Kuosa
 *	2010-12
 *
 *	Event Handling Trigger class
 */

#ifndef VL_TRIGGER_HPP
#define VL_TRIGGER_HPP

#include "keycode.hpp"

#include "action.hpp"

namespace vl
{

// TODO add str conversions to python
// TODO add event to print all the events (do this in python)


/// Base class for all Triggers
/// Abstract
class Trigger
{
public :
	bool operator==( Trigger const &other ) const
	{
		return ((typeid(*this) == typeid(other)) && isEqual(other));
	}

	/// Returns wether Triggers are similar enough
	/// Specifics depend on the derived class and how they handle this
	/// but basicly this returns true if the this is a specialisation of other
	/// or they are equal.
	bool isSimilar( Trigger const *other ) const
	{
		return (*this == *other || isSpecialisation( other ) );
	}

	/// Returns true if is a specialisation of other
	virtual bool isSpecialisation( Trigger const *other ) const = 0;

	virtual double value( void ) const = 0;

	virtual bool isEqual( Trigger const &other ) const = 0;

	virtual std::string const &getTypeName( void ) const = 0;

	virtual std::string getName( void ) const = 0;

	virtual std::ostream & print( std::ostream & os ) const
	{
		os << "Trigger : " << getTypeName() << std::endl;
		return os;
	}

};

inline std::ostream &operator<<( std::ostream &os, vl::Trigger const &t )
{ return t.print( os ); }


/// Trigger Factory class for creating new Triggers
class TriggerFactory
{
public :
	virtual Trigger *create( void ) = 0;
	virtual std::string const &getTypeName( void ) const = 0;
};

class BasicActionTrigger : public vl::Trigger
{
public :
	BasicActionTrigger( void )
		: _action(0)
	{}

	/// Action to execute when updated
	// TODO there should be a stack of actions not just one of them
	virtual void setAction( BasicActionPtr action )
	{
		_action = action;
	}

	virtual BasicActionPtr getAction( void )
	{
		return _action;
	}

	/// Callback function
	virtual void update( void )
	{
		if( _action )
		{ _action->execute(); }
	}

private :
	BasicActionPtr _action;
};

class TransformActionTrigger : public vl::Trigger
{
public :
	TransformActionTrigger( void )
		: _action(0)
	{}

	/// Action to execute when updated
	// TODO there should be a stack of actions not just one of them
	void setAction( TransformActionPtr action )
	{
		if( _action != action )
		{
			_action = action;

			update(_value);
		}
	}

	TransformActionPtr getAction( void )
	{ return _action; }

	/// Callback function
	void update( Transform const &data )
	{
		// Copy the data for futher reference
		_value = data;
		if( _action )
		{
			_action->execute(data);
		}
	}

protected :
	TransformActionPtr _action;

	Transform _value;
};

class KeyTrigger : public BasicActionTrigger
{
public :
	KeyTrigger( void );

	void setKey( OIS::KeyCode key )
	{ _key = key; }

	OIS::KeyCode getKey( void ) const
	{ return _key; }

	virtual double value( void ) const
	{ return 1; }

	virtual bool isSpecialisation( Trigger const *other ) const;

	virtual bool isEqual( Trigger const &other ) const;

	virtual std::string const &getTypeName( void ) const;

	virtual std::ostream & print( std::ostream & os ) const;

	virtual std::string getName( void ) const
	{ return vl::getKeyName( _key ); }

private :
	OIS::KeyCode _key;
};


class KeyTriggerFactory : public TriggerFactory
{
public :
	virtual Trigger *create( void )
	{ return new KeyTrigger; }

	virtual std::string const &getTypeName( void ) const
	{ return TYPENAME; }

	static const std::string TYPENAME;
};


/// Specialization of KeyTrigger that checks if that the key is pressed
/// All triggers generated by keyEvents are of these specializations
class KeyPressedTrigger : public KeyTrigger
{
	virtual std::string const &getTypeName( void ) const;

	/// Pressed always returns 1 (positive)
	virtual double value( void ) const
	{ return 1; }

	virtual bool isSpecialisation( Trigger const *other ) const;
};

class KeyPressedTriggerFactory : public TriggerFactory
{
public :
	virtual Trigger *create( void )
	{ return new KeyPressedTrigger; }

	virtual std::string const &getTypeName( void ) const
	{ return TYPENAME; }

	static const std::string TYPENAME;
};

/// Specialization of KeyTrigger that checks if that the key is released
/// All triggers generated by keyEvents are of these specializations
class KeyReleasedTrigger : public KeyTrigger
{
	virtual std::string const &getTypeName( void ) const;

	/// Released always returns -1 (negative)
	virtual double value( void ) const
	{ return -1; }

	virtual bool isSpecialisation( Trigger const *other ) const;

};

class KeyReleasedTriggerFactory : public TriggerFactory
{
public :
	virtual Trigger *create( void )
	{ return new KeyReleasedTrigger; }

	virtual std::string const &getTypeName( void ) const
	{ return TYPENAME; }

	static const std::string TYPENAME;
};

/// Trigger that is triggered when a frame is rendered
// TODO should be a float trigger, so that the frame time can be passed
// the actions this executes
class FrameTrigger : public BasicActionTrigger
{
public :
	FrameTrigger( void )
		: _delta_time(0)
	{}

	virtual bool isEqual( Trigger const &other ) const
	{
		return true;
	}

	virtual std::string const &getTypeName( void ) const;

	void setDeltaTime( double delta_time )
	{ _delta_time = delta_time; }

	virtual double value( void ) const
	{ return _delta_time; }

	virtual bool isSpecialisation( Trigger const *other ) const
	{ return false; }

	virtual std::string getName( void ) const
	{ return "FrameTrigger"; }

protected :
	double _delta_time;

};

class FrameTriggerFactory : public TriggerFactory
{
public :
	virtual Trigger *create( void )
	{ return new KeyTrigger; }

	virtual std::string const &getTypeName( void ) const
	{ return TYPENAME; }

	static const std::string TYPENAME;
};

}	// namespace vl

#endif // VL_TRIGGER_HPP
