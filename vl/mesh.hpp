/**	@author Joonatan Kuosa <joonatan.kuosa@tut.fi>
 *	@date 2011-05
 *	@file mesh.hpp
 *
 *	Mesh data structure, no real functionality but can be copied to
 *	Ogre and/or Bullet as the user sees fit.
 *	Also used by the serialization modules used by editor and exporters.
 *
 *	Minamal wrappers for Ogre Mesh so that we don't need Ogre to read, write
 *	or modify these structures.
 */

#ifndef HYDRA_MESH_HPP
#define HYDRA_MESH_HPP

#include <vector>
#include <string>

#include <boost/tuple/tuple.hpp>

#include <OGRE/OgreVector2.h>
#include <OGRE/OgreVector3.h>
#include <OGRE/OgreColourValue.h>
#include <OGRE/OgreAxisAlignedBox.h>
#include <OGRE/OgreMesh.h>

#include "typedefs.hpp"

namespace vl
{

/// @todo the parameters in the vertex should be optional
/// for example we could use an array with offsets (similar to VertexData), hard to use
/// or we could use a stack of Vertex attributes
/// or we could use multiple Vertex structures
struct Vertex
{
	Ogre::Vector3 position;
	Ogre::Vector3 normal;
	Ogre::ColourValue diffuse;
	Ogre::ColourValue specular;
	Ogre::Vector2 uv;
};

std::ostream &operator<<( std::ostream &os, Vertex const &v );


/// Wrappers for Ogre::Mesh for writing and reading them
/// @class SubMesh
/// @todo add merge, merges SubMeshes and uses the material of the first one
/// @todo add getPolygonCount
/// no support for quads because they are ambigious and Ogre does not support them
class SubMesh
{
public :
	SubMesh(void) {}

	~SubMesh(void) {}

	std::string const &getName(void)
	{ return _name; }

	void setName(std::string const &name)
	{ _name = name; }
	
	std::string const &getMaterial(void)
	{ return _material; }

	void setMaterial(std::string const &material)
	{ _material = material; }

	void addFace(int i1, int i2, int i3)
	{ _faces.push_back( boost::make_tuple(i1, i2, i3) ); }

	boost::tuple<int, int, int> const &getFace(size_t i)
	{ return _faces.at(i); }

	size_t getNumFaces(void)
	{ return _faces.size(); }

private :
	std::string _name;
	std::string _material;
	std::vector< boost::tuple<int, int, int> > _faces;
};


std::ostream &operator<<( std::ostream &os, SubMesh const &m );
/// @class Mesh
/// @todo add rebuildTangents function, similar to the one in Ogre::Mesh
/// @todo add calculateSmoothNormals, for Blender exporter
/// @todo add calculateBounds, for autogenerated meshes
/// @todo add getPolygonCount, calculates the number of polygons in all SubMeshes
/// @todo add merge, merges two meshes and preserving their SubMeshes
/// @todo add name, used as file name and to distinguis the Mesh
/// @todo add mergeSubMeshes, merges all SubMeshes to one and uses the material supplied
class Mesh
{
public :
	Mesh(void)
		: _bound_radius(0)
	{}

	~Mesh(void);

	void addVertex(Vertex const &vertex)
	{ _vertices.push_back(vertex); }

	Vertex const &getVertex(size_t i) const
	{ return _vertices.at(i); }

	size_t getNumVertices(void) const
	{ return _vertices.size(); }

	SubMesh *createSubMesh(void);

	SubMesh *getSubMesh(unsigned int size)
	{ return _sub_meshes.at(size); }

	unsigned int getNumSubMeshes(void) const
	{ return _sub_meshes.size(); }

	Ogre::AxisAlignedBox const &getBounds(void) const
	{ return _bounds; }

	void setBounds(Ogre::AxisAlignedBox const &box)
	{ _bounds = box; }

	Ogre::Real getBoundingSphereRadius(void) const
	{ return _bound_radius; }

	void setBoundingSphereRadius(Ogre::Real radius)
	{ _bound_radius = radius; }

private :
	std::vector<Vertex> _vertices;
	std::vector<SubMesh *> _sub_meshes;
	Ogre::AxisAlignedBox _bounds;
	Ogre::Real _bound_radius;
};

Ogre::MeshPtr create_ogre_mesh(std::string const &name, vl::MeshRefPtr mesh);

void convert_ogre_geometry(vl::Mesh *mesh, Ogre::VertexData *vertexData, Ogre::Mesh *og_mesh);

void convert_ogre_submeshes(vl::Mesh *mesh, Ogre::Mesh *og_mesh);

void convert_ogre_submesh(vl::SubMesh *mesh, Ogre::SubMesh *og_sm);

std::ostream &operator<<( std::ostream &os, Mesh const &m );

}	// namespace vl

#endif	// HYDRA_MESH_HPP
