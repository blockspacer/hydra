/**	@author Joonatan Kuosa <joonatan.kuosa@tut.fi>
 *	@date 2011-05
 *	@file mesh.hpp
 *
 *	Mesh data structure, no real functionality but can be copied to
 *	Ogre and/or Bullet as the user sees fit.
 *	Also used by the serialization modules used by editor and exporters.
 *
 *	Minamal wrappers for Ogre Mesh so that we don't need Ogre to read, write
 *	or modify these structures.
 */

#ifndef HYDRA_MESH_HPP
#define HYDRA_MESH_HPP

#include <vector>
#include <string>

#include <boost/tuple/tuple.hpp>

#include <OGRE/OgreVector2.h>
#include <OGRE/OgreVector3.h>
#include <OGRE/OgreColourValue.h>
#include <OGRE/OgreAxisAlignedBox.h>
#include <OGRE/OgreMesh.h>

/// Necessary for Ref ptrs
#include "typedefs.hpp"
/// Necessary for serializing Meshes
#include "cluster/message.hpp"

namespace vl
{

/// @todo the parameters in the vertex should be optional
/// for example we could use an array with offsets (similar to VertexData), hard to use
/// or we could use a stack of Vertex attributes
/// or we could use multiple Vertex structures
struct Vertex
{
	Ogre::Vector3 position;
	Ogre::Vector3 normal;
	Ogre::ColourValue diffuse;
	Ogre::ColourValue specular;
	Ogre::Vector2 uv;
};

std::ostream &operator<<( std::ostream &os, Vertex const &v );


/// Wrappers for Ogre::Mesh for writing and reading them
/// @class SubMesh
/// @todo add merge, merges SubMeshes and uses the material of the first one
/// @todo add getPolygonCount
/// no support for quads because they are ambigious and Ogre does not support them
class SubMesh
{
public :
	SubMesh(void) {}

	~SubMesh(void) {}

	std::string const &getName(void) const
	{ return _name; }

	void setName(std::string const &name)
	{ _name = name; }
	
	std::string const &getMaterial(void) const
	{ return _material; }

	void setMaterial(std::string const &material)
	{ _material = material; }

	void addFace(int i1, int i2, int i3)
	{ _faces.push_back( boost::make_tuple(i1, i2, i3) ); }

	boost::tuple<int, int, int> const &getFace(size_t i) const
	{ return _faces.at(i); }

	size_t getNumFaces(void) const
	{ return _faces.size(); }

	typedef std::vector< boost::tuple<int, int, int> > FaceList;

	FaceList const &getFaces(void) const
	{ return _faces; }

private :
	std::string _name;
	std::string _material;
	FaceList _faces;
};


std::ostream &operator<<( std::ostream &os, SubMesh const &m );
/// @class Mesh
/// @todo add rebuildTangents function, similar to the one in Ogre::Mesh
/// @todo add calculateSmoothNormals, for Blender exporter
/// @todo add calculateBounds, for autogenerated meshes
/// @todo add getPolygonCount, calculates the number of polygons in all SubMeshes
/// @todo add merge, merges two meshes and preserving their SubMeshes
/// @todo add name, used as file name and to distinguis the Mesh
/// @todo add mergeSubMeshes, merges all SubMeshes to one and uses the material supplied
class Mesh
{
public :
	Mesh(void)
		: _bound_radius(0)
	{}

	~Mesh(void);

	void addVertex(Vertex const &vertex)
	{ _vertices.push_back(vertex); }

	Vertex const &getVertex(size_t i) const
	{ return _vertices.at(i); }

	size_t getNumVertices(void) const
	{ return _vertices.size(); }

	SubMesh *createSubMesh(void);

	SubMesh *getSubMesh(unsigned int size)
	{ return _sub_meshes.at(size); }

	unsigned int getNumSubMeshes(void) const
	{ return _sub_meshes.size(); }

	Ogre::AxisAlignedBox const &getBounds(void) const
	{ return _bounds; }

	void setBounds(Ogre::AxisAlignedBox const &box)
	{ _bounds = box; }

	Ogre::Real getBoundingSphereRadius(void) const
	{ return _bound_radius; }

	void setBoundingSphereRadius(Ogre::Real radius)
	{ _bound_radius = radius; }

	typedef std::vector<Vertex> VertexList;
	typedef std::vector<SubMesh *> SubMeshList;

	VertexList &getVertices(void)
	{ return _vertices; }

	VertexList const &getVertices(void) const
	{ return _vertices; }

	SubMeshList &getSubMeshes(void)
	{ return _sub_meshes; }

	SubMeshList const &getSubMeshes(void) const
	{ return _sub_meshes; }

private :
	VertexList _vertices;
	SubMeshList _sub_meshes;
	Ogre::AxisAlignedBox _bounds;
	Ogre::Real _bound_radius;
};

Ogre::MeshPtr create_ogre_mesh(std::string const &name, vl::MeshRefPtr mesh);

void convert_ogre_geometry(vl::Mesh *mesh, Ogre::VertexData *vertexData, Ogre::Mesh *og_mesh);

void convert_ogre_submeshes(vl::Mesh *mesh, Ogre::Mesh *og_mesh);

void convert_ogre_submesh(vl::SubMesh *mesh, Ogre::SubMesh *og_sm);

std::ostream &operator<<( std::ostream &os, Mesh const &m );

namespace cluster
{

template<> inline
ByteStream &operator<<(ByteStream &msg, vl::SubMesh const &mesh)
{
	std::clog << "Serializing SubMesh." << std::endl;
	/// @todo does msg << mesh.getFaces() work really?
	msg << mesh.getName() << mesh.getMaterial() << mesh.getFaces();

	return msg;
}

template<> inline
ByteStream &operator>>(ByteStream &msg, vl::SubMesh &mesh)
{
	std::clog << "Serializing SubMesh." << std::endl;
	std::string name;
	std::string material;
	size_t n_faces;

	msg >> name >> material >> n_faces;
	for(size_t i = 0; i < n_faces; ++i)
	{
		int f1, f2, f3;
		msg >> f1 >> f2 >> f3;
		mesh.addFace(f1, f2, f3);
	}

	return msg;
}

template<> inline
ByteStream &operator<<(ByteStream &msg, vl::Mesh const &mesh)
{
	std::clog << "Serializing Mesh." << std::endl;
	/// @todo add writing
	msg << mesh.getVertices() << mesh.getBoundingSphereRadius() << mesh.getBounds();
	msg << mesh.getSubMeshes().size();
	for(size_t i = 0; i < mesh.getSubMeshes().size(); ++i)
	{ msg << *mesh.getSubMeshes().at(i); }

	return msg;
}

template<> inline
ByteStream &operator>>(ByteStream &msg, vl::Mesh &mesh)
{
	std::clog << "Deserializing Mesh." << std::endl;
	Ogre::Real radius;
	Ogre::AxisAlignedBox bounds;
	size_t n_s_meshes;
	msg >> mesh.getVertices() >> radius >> bounds >> n_s_meshes;
	mesh.setBoundingSphereRadius(radius);
	mesh.setBounds(bounds);

	for(size_t i = 0; i < n_s_meshes; ++i)
	{
		SubMesh *sm = mesh.createSubMesh();
		msg >> *sm;
	}

	return msg;
}

}	// namespace cluster

}	// namespace vl

#endif	// HYDRA_MESH_HPP
